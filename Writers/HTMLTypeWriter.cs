using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Xml.XPath;

namespace HTMLDocumentation
{
    /// <summary>
    /// An HTMLWriter which specifically writes a class
    /// </summary>
    public class HTMLTypeWriter : HTMLWriter
    {
        #region Properties and Fields

        /// <summary>
        /// The current type that we are writing out to a documentation page.
        /// </summary>
        private Type Type { get; set; }

        /// <summary>
        /// The documentation XML generated by visual studio
        /// </summary>
        private XPathDocument Documentation { get; set; }

        /// <summary>
        /// The public instance methods declared in this class
        /// </summary>
        private List<MethodInfo> PublicInstanceMethods { get; set; }

        /// <summary>
        /// The non-public instance methods declared in this class
        /// </summary>
        private List<MethodInfo> NonPublicInstanceMethods { get; set; }

        #endregion

        public HTMLTypeWriter(Type type, string documentationFilePath) :
            base(documentationFilePath)
        {
            Type = type;
        }

        #region Virtual Functions

        protected override void MarshalData()
        {
            base.MarshalData();

            // Ultimately I think we want to compile the docs ourselves for each class - do this with Process and then see the docs on msdn for compiling docs
            string xmlDocs = Directory.GetCurrentDirectory() + "\\" + Assembly.GetExecutingAssembly().GetName().Name + ".xml";
            Documentation = new XPathDocument(xmlDocs);

            MethodInfo[] info = Type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);
            PublicInstanceMethods = new List<MethodInfo>();
            // Only write methods that are declared in this class and are not getters and setters for Properties
            PublicInstanceMethods.RemoveAll(x => !ShouldWriteMethod(x));

            NonPublicInstanceMethods = new List<MethodInfo>(Type.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly));
            // Only write methods that are declared in this class and are not getters and setters for Properties
            NonPublicInstanceMethods.RemoveAll(x => !ShouldWriteMethod(x));
        }

        /// <summary>
        /// Set up the style sheet and title for the Class documentation page.
        /// </summary>
        protected override void WriteHead()
        {
            base.WriteHead();

            WriteLine("<title>" + Type.Name + "</title>");
        }

        /// <summary>
        /// Write each of the different type of methods in an accordion structure
        /// </summary>
        protected override void WriteBody()
        {
            base.WriteBody();

            WriteSideBar();

            WriteLine("<div style=\"margin-left:200px\">");

            WritePageHeader();
            WriteNavBar();

            /*
            * Have headers + bookmarks for each section (Instance and static, then subsections of public & non-public)
            * Don't write property setters and getters - do that in properties - remove the setters and getters when we iterate over properties?
            * Template arguments etc.
            * Document properties, fields, events
            */

            // Methods
            {
                WriteLine("<h2 id=\"public_methods\">Public Methods</h2>");

                Indent();
                // Write public instance methods declared by this type
                WriteMethods(PublicInstanceMethods);
                UnIndent();

                WriteLine("<h2 id=\"non_public_methods\">Non Public Methods</h2>");

                Indent();
                // Write non public instance methods declared by this type
                WriteMethods(NonPublicInstanceMethods);
                UnIndent();
            }

            WriteLine("</div>");
        }

        #endregion

        #region Body Writing Utility Functions

        /// <summary>
        /// Write the side bar for navigation of sections for this class
        /// </summary>
        private void WriteSideBar()
        {
            WriteLine("<nav class=\"w3-sidenav w3-white\" style=\"width:200px;\" id=\"pageSideBar\">");
            Indent();

            WriteLine("<h6 class=\"w3-center\">Sections</h6>");
            WriteLine("<a class=\"w3-pale-blue w3-border w3-border-blue w3-hover-white w3-margin\" href=\"#page_body\">Page Top</a>");
            WriteLine("<a class=\"w3-pale-blue w3-border w3-border-blue w3-hover-white w3-margin\" href=\"#public_methods\">Public Methods</a>");

            foreach (MethodInfo method in PublicInstanceMethods)
            {
                WriteLine("<a class=\"w3-margin-left w3-small\" href=\"#" + method.Name + "\">" + method.Name + "</a>");
            }

            WriteLine("<a class=\"w3-pale-blue w3-border w3-border-blue w3-hover-white w3-margin\" href=\"#non_public_methods\">Non Public Methods</a>");

            foreach (MethodInfo method in NonPublicInstanceMethods)
            {
                WriteLine("<a class=\"w3-margin-left w3-small\" href=\"#" + method.Name + "\">" + method.Name + "</a>");
            }

            UnIndent();
            WriteLine("</nav>");
        }

        /// <summary>
        /// Write the header section of our body which holds the title of the page.
        /// </summary>
        private void WritePageHeader()
        {
            WriteLine("<header class=\"w3-container w3-blue w3-center\">");
            WriteLine("<h1 id=\"page_title\">" + Type.Name + " Class</h1>");
            WriteLine("</header>");
        }

        /// <summary>
        /// Write the nav bar along the top for navigation of files in this directory
        /// </summary>
        private void WriteNavBar()
        {
            // Create a navbar for files in this directory
            WriteLine("<ul class=\"w3-navbar w3-border w3-light-grey\">");
            Indent();

            // Write a link back to the linker for the directory this type's .cs file is in
            FileInfo[] infos = ContentManager.CodeDirectory.GetFiles(Type.Name + ".cs", SearchOption.AllDirectories);
            Debug.Assert(infos.Length == 1);

            // Write the main link back to the directory linker
            FileInfo thisTypeFileInfo = infos[0];
            WriteLine("<li><a class=\"w3-pale-red w3-hover-red\" href=\"" + thisTypeFileInfo.Directory.Name + HTMLDirectoryLinkerWriter.LinkerString + "\">Parent Directory</a></li>");

            UnIndent();
            WriteLine("</ul>");
        }

        #endregion

        #region Method Writing Utility Functions

        /// <summary>
        /// Utility function for determining whether a method should be written to this type's HTML page.
        /// Returns true if the method was declared inside the type we are writing and is not a getter or setter for a property.
        /// The compiler also seems to generate private methods at runtime so we check to make sure we do not have one
        /// </summary>
        /// <param name="method">The method we should check to write</param>
        /// <returns>True if we should write the method and false if we should not</returns>
        private bool ShouldWriteMethod(MethodInfo method)
        {
            return Type.Name == method.DeclaringType.Name &&
                   !method.Name.StartsWith("get_") &&
                   !method.Name.StartsWith("set_") &&
                   method.GetCustomAttribute<CompilerGeneratedAttribute>() == null;
        }

        /// <summary>
        /// Iterates over all the inputted methods.  These are guarenteed to satisfy the ShouldWriteMethod.
        /// </summary>
        /// <param name="methods"></param>
        private void WriteMethods(List<MethodInfo> methods)
        {
            foreach (MethodInfo method in methods)
            {
                WriteMethod(method);
            }
        }

        /// <summary>
        /// Writes all the information about a method, including:
        /// Parameters
        /// Return type
        /// Template arguments
        /// Whether it is virtual
        /// </summary>
        private void WriteMethod(MethodInfo method)
        {
            ParameterInfo[] parameters = method.GetParameters();

            // Construct the html for the parameters
            string parametersString = "(";
            for (int i = 0; i < parameters.Length; i++)
            {
                ParameterInfo parameter = parameters[i];
                parametersString += "<span title=\"Parameter type\" class=\"parameter_type\">" + 
                    parameter.ParameterType.Name + "</span> <span title=\"Parameter name\">" + parameter.Name + "</span>";

                // Add the delimiter if we have arguments left
                if (i < parameters.Length - 1)
                {
                    parametersString += ", ";
                }
            }
            parametersString += ")";

            WriteLine("<div class=\"w3-card-4 w3-margin-top w3-margin-bottom\">");
            Indent();

            // Construct the html for the return type
            //string returnTypeString = "<span title=\"Return type\" class=\"return_type\">" + method.ReturnParameter.ParameterType.Name + "</span> ";

            //// Construct the html for the method name
            string methodString = method.Name;
            if (method.IsVirtual)
            {
                methodString += " <span class=\"w3-tag w3-margin-left w3-blue\">Virtual</span>";
            }

            WriteLine("<header id=\"" + method.Name + "\" class=\"w3-container w3-pale-blue w3-leftbar w3-border-blue w3-hover-shadow\">");
            Indent();
                WriteLine("<h6>" + methodString + "</h6>");
            UnIndent();
            WriteLine("</header>");

            WriteLine("<div class=\"w3-container\">");
            Indent();

            XPathNavigator methodNode = GetXMLDocNodeForMethod(method);
            if (methodNode != null)
            {
                List<ParameterInfo> parametersInfo = method.GetParameters().ToList();

                // Construct the html for the comment on the method
                XPathNavigator clone;
                {
                    clone = methodNode.Clone();
                    clone.MoveToChild("summary", "");

                    WriteLine("<h6 class=\"w3-text-cyan w3-margin-top w3-margin-bottom\" style=\"margin-left:6px\">Description</h6>");
                    WriteLine("<p class=\"w3-margin-left w3-margin-top w3-margin-bottom\">" + clone.InnerXml.Trim(' ', '\r', '\n') + "</p>");
                }

                // Construct the html for the comments on the parameters
                {
                    clone = methodNode.Clone();
                    XPathNodeIterator childParams = clone.SelectChildren("param", "");

                    WriteLine("<h6 class=\"w3-text-deep-purple w3-margin-top w3-margin-bottom\" style=\"margin-left:6px\">Parameters</h6>");
                    while (childParams.MoveNext())
                    {
                        string parameterName = childParams.Current.GetAttribute("name", "");
                        Debug.Assert(parametersInfo.Exists(x => x.Name == parameterName), "TODO - add a tag in the document to indicate the name is out of date and should be updated");
                        string parameterType = parametersInfo.Find(x => x.Name == parameterName).ParameterType.Name;

                        WriteLine("<p class=\"w3-margin-left w3-margin-top w3-margin-bottom\"><span class=\"w3-tag w3-purple\"> " + parameterType + "</span>" + " '" + parameterName + "': " + childParams.Current.InnerXml + " </p>");
                    }
                }

                // Construct the html for the comment on the return type (if it exists)
                {
                    WriteLine("<h6 class=\"w3-text-orange w3-margin-top w3-margin-bottom\" style=\"margin-left:6px\">Returns<span class=\"w3-tag w3-margin-left w3-pale-yellow\"> " + method.ReturnType.Name + "</span></h6>");

                    clone = methodNode.Clone();
                    if (clone.MoveToChild("returns", ""))
                    {
                        WriteLine("<p class=\"w3-margin-left w3-margin-top w3-margin-bottom\">" + clone.InnerXml + "</p>");
                    }
                }
            }

            UnIndent();
            WriteLine("</div>");

            UnIndent();
            WriteLine("</div>");
        }

        /// <summary>
        /// Uses the input method to find the appropriate node in the documentation XML file and
        /// returns the XPathNavigator at that position.
        /// </summary>
        /// <param name="method"></param>
        private XPathNavigator GetXMLDocNodeForMethod(MethodInfo method)
        {
            XPathNavigator nav = Documentation.CreateNavigator();

            nav.MoveToRoot();
            nav.MoveToFirstChild();
            nav.MoveToChild("members", "");

            //string containsString = "contains(@name, '" + Type.Name + "') and contains(@name, '" + method.Name + "(')";
            //int index = 0;
            //foreach (ParameterInfo parameter in method.GetParameters())
            //{
            //    if (index < method.GetParameters().Length)
            //    {
            //        containsString += " and ";
            //    }

            //    containsString += "contains(@name, '" + parameter.ParameterType.Name + "')";
            //    index++;
            //}

            string fullString = "contains(@name, '" + method.DeclaringType.FullName + "." + method.Name + "(')";
            string xPath = "//member[" + fullString + "]";
            nav = nav.SelectSingleNode(xPath);

            return nav;
        }

        #endregion
    }
}
